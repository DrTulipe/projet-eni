'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var reactDom = require('react-dom');
var core = require('@fullcalendar/core');
var internal = require('@fullcalendar/core/internal');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

/* eslint-disable @typescript-eslint/no-explicit-any */
class FullCalendar extends React.Component {
    constructor() {
        super(...arguments);
        this.elRef = React.createRef();
        this.needsCustomRenderingResize = false;
        this.isInitialRender = true;
        this.state = {
            customRenderingMap: new Map()
        };
    }
    render() {
        const portalNodes = [];
        for (const customRendering of this.state.customRenderingMap.values()) {
            const { generatorMeta } = customRendering;
            const vnode = typeof generatorMeta === 'function' ?
                generatorMeta(customRendering.renderProps) :
                generatorMeta;
            portalNodes.push(reactDom.createPortal(vnode, customRendering.containerEl, customRendering.id));
        }
        return (React__default["default"].createElement("div", { ref: this.elRef }, portalNodes));
    }
    componentDidMount() {
        const customRenderingStore = new internal.CustomRenderingStore();
        this.calendar = new core.Calendar(this.elRef.current, Object.assign(Object.assign({}, this.props), { handleCustomRendering: customRenderingStore.handle.bind(customRenderingStore), customRenderingMetaMap: this.props }));
        this.calendar.render();
        customRenderingStore.subscribe((customRenderingMap) => {
            if (this.isInitialRender) {
                this.doCustomRendering(customRenderingMap);
            }
            else {
                this.requestCustomRendering(customRenderingMap);
            }
        });
    }
    requestCustomRendering(customRenderingMap) {
        this.cancelCustomRendering();
        this.customRenderingRequestId = requestAnimationFrame(() => {
            FullCalendar.act(() => {
                this.doCustomRendering(customRenderingMap);
            });
        });
    }
    doCustomRendering(customRenderingMap) {
        this.needsCustomRenderingResize = true;
        this.setState({ customRenderingMap });
    }
    cancelCustomRendering() {
        if (this.customRenderingRequestId) {
            cancelAnimationFrame(this.customRenderingRequestId);
            this.customRenderingRequestId = undefined;
        }
    }
    componentDidUpdate(prevProps) {
        this.isInitialRender = false;
        const updates = computeUpdates(prevProps, this.props);
        if (Object.keys(updates).length) {
            this.calendar.resetOptions(Object.assign(Object.assign({}, updates), { customRenderingMetaMap: this.props }), true);
        }
        if (this.needsCustomRenderingResize) {
            this.needsCustomRenderingResize = false;
            this.calendar.updateSize();
        }
    }
    componentWillUnmount() {
        this.calendar.destroy();
        this.cancelCustomRendering();
    }
    getApi() {
        return this.calendar;
    }
}
FullCalendar.act = (f) => { f(); };
// Utils
function computeUpdates(origObj, newObj) {
    const updates = {};
    if (newObj !== origObj) {
        for (const key in newObj) {
            if (newObj[key] !== origObj[key]) {
                updates[key] = newObj[key];
            }
        }
    }
    return updates;
}

exports["default"] = FullCalendar;
